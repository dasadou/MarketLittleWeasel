console.log("in the console CCC")
const { TABLE_ELEMENT, PRICE_ELEMENT } = require('../src/constants');

function hideArticles(startIndex) {
  let table = document.querySelector(TABLE_ELEMENT);

  const children = table.children;
  const keywordRegex = new RegExp(keyword, "i"); // Compile regular expression outside of loop

  for (let i = startIndex; i < children.length; i++) {
    const childNode = children[i];
    const grandChildNode = childNode.querySelector(".x1lliihq.x6ikm8r.x10wlt62.x1n2onr6"); // Where the name is located

    if (grandChildNode) { // Check if grandChildNode is not null
      const articleName = grandChildNode.textContent; // The name of the article

      if (!keywordRegex.test(articleName)) { // If the article name does not contain the keyword
        childNode.style.display = "none"; // Hide the child node
      } else {
        const priceElement = childNode.querySelector(PRICE_ELEMENT);
        const linkElement = childNode.querySelector("[role='link']");

        if (priceElement && linkElement) {
          const priceText = priceElement.textContent;
          const price = parseFloat(priceText.replace(/[^0-9\.]/g, "").replace(/(\.[0-9]*?)0+$/, "$1").replace(/\.$/, ""));
          const link = linkElement.href;
          articles.set(link, { name: articleName, price: price, link: link }); // Save the article
        }
      }
    }
  }
}


// Options for the observer (which mutations to observe)
const config = { childList: true };

let timeoutId = null;
// Callback function to execute when mutations are observed
const callback = function (mutationsList, observer) {
  for (let mutation of mutationsList) {
    if (mutation.type === 'childList') {
      // Debounce hideArticles function
      clearTimeout(timeoutId);
      timeoutId = setTimeout(() => hideArticles(mutation.addedNodes.length), 10); // Hide new articles
    }
  }
};

// Create an observer instance linked to the callback function
const observer = new MutationObserver(callback);

function showAll() {
  const children = table.children;
  for (let i = 0; i < children.length; i++) {
    const childNode = children[i];
    childNode.style.display = ""; // Unhide the child node
  }
}

// Listen for messages from the popup
chrome.runtime.onMessage.addListener((request, sender, sendResponse) => {
  if (request.message === 'start') {
    console.log("start");
    keyword = request.keyword;
    hideArticles(0); // Initial hiding of articles
    observer.observe(table, config); // Start observing
  } else if (request.message === 'stop') {
    console.log("stop");

    observer.disconnect(); // Stop observing
    articles.clear();
    sendResponse({ articles: Array.from(articles.values()) }); // Send articles as response
  } else if (request.message === 'showAll') {
    console.log("showAll");

    showAll(); // Show all hidden items
  } else if (request.message === 'getArticles') {
    console.log("get");

    sendResponse({ articles: Array.from(articles.values()) });
  }
});